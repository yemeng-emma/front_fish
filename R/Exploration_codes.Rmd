---
title: "Exploring data in progress"
author: "Meng Ye"
date: "2025-08-24"
output: html_document
---

## Set up and import data 

```{r setup, include=FALSE}
# Set global random seed for reproducibility
set.seed(820461) #generated at random.org
```


```{r packages message=FALSE, warning=FALSE}
#load packages
library(tidyverse)        # ggplot, dplyr, and friends
library(broom)            # Convert model objects to tidy data frames
library(broom.mixed)      # Convert mixed model objects to tidy data frames
library(parameters)       # Show model results as nice tables
library(scales)           # Nicer labeling functions
library(marginaleffects)  # Calculate marginal effects
library(ggforce)          # For facet_col()
library(brms)             # The best formula-based interface to Stan
library(tidybayes)        # Manipulate Stan results in tidy ways
library(ggdist)           # Fancy distribution plots
library(patchwork)        # Combine ggplot plots
library(ggtext)           # For plot formatting
library(rcartocolor)      # Color palettes from CARTOColors (https://carto.com/carto-colors/)
library(here)             # managing directory
library(readxl)           # read excel files
library(janitor)          # clean column names 

```

```{r plot setting message=FALSE, warning=FALSE}
#load packages
# Custom ggplot theme to make pretty plots
# Get the font at https://github.com/intel/clear-sans
theme_nice <- function() {
  theme_minimal() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(face = "bold"),
          axis.title.x = element_text(hjust = 0),
          axis.title.y = element_text(hjust = 1),
          strip.text = element_text(face = "bold",
                                    size = rel(0.75), hjust = 0),
          strip.background = element_rect(fill = "grey90", color = NA))
}

theme_set(theme_nice())

clrs <- carto_pal(name = "Prism")

# Functions for formatting things as percentage points
label_pp <- label_number(accuracy = 1, scale = 100, 
                         suffix = " pp.", style_negative = "minus")
```


```{r data, message=FALSE, warning=FALSE}
# survey data
survey <- read_excel(here("data", "raw_data", "data_survey1.xlsx")) |>
          clean_names() |>
          rename_with(~ gsub("^x[0-9_]+", "", .x))

# conjoint specific levels and choices 
choices <- read_excel(here("data", "raw_data", "data_choice1.xlsx")) |>
           clean_names() |>
           filter(concept != 4) # filter out none option as seperate lines (information redundant) 
# Prolific demographic 

demogr <- read_csv(here("data", "raw_data", "data_demogr1.csv")) |>
          clean_names()
```



## robustness checks prep 

1. check for duplicated records: NONE

```{r}
# Check for duplicated Prolific IDs
duplicated_ids <- survey$prolific[duplicated(survey$prolific)]

# View the duplicated IDs
duplicated_ids

# Count how many duplicates
length(duplicated_ids)

# Optional: get full rows of duplicated IDs
survey[duplicated(survey$prolific) | duplicated(survey$prolific, fromLast = TRUE), ]

#character(0)
#[1] 0
## no duplicates
```

2. Attention checks

```{r}
survey |>
  count(attention)
```
1181 passed attention checks 3 did not answer


3. Very short answering time

```{r}
summary(survey$elapsed_time_hh_mm_ss)
```

```{r}
library(lubridate)

survey_time <- survey |>
  mutate(
    # Extract time part (ignoring the arbitrary date)
    time_str = str_extract(elapsed_time_hh_mm_ss, "\\d{2}:\\d{2}:\\d{2}"),
    # Convert to seconds
    elapsed_seconds = period_to_seconds(hms(time_str))
  )
```


```{r}
percentile_threshold <- quantile(survey_time$elapsed_seconds, 0.01, na.rm = TRUE)
percentile_threshold
```
```{r include=FALSE, eval=interactive()}
# Identify fast respondents
fast_respondents <- survey_time %>%
  filter(elapsed_seconds < percentile_threshold)
nrow(fast_respondents)
```

```{r}
survey_notshort <- survey_time |>
  filter(elapsed_seconds >= percentile_threshold)
```


4. Same answer across tasks

```{r}
cbc_cols <- paste0("cbc1_", 1:10)

survey_always <- survey |>
  rowwise() |>
  mutate(
    always_same_choice = n_distinct(c_across(all_of(cbc_cols)), na.rm = TRUE) == 1
  ) |>
  ungroup()

survey_always |>
  count(always_same_choice)
```

5. Derive robustness check data frame by filtering out the three conditions

```{r}
survey_robust <- survey |>
  # filter out NA answers for attention check questions
  filter(!is.na(attention)) |>
  # filter out answers with very short time span
  mutate(
    # Extract time part (ignoring the arbitrary date)
    time_str = str_extract(elapsed_time_hh_mm_ss, "\\d{2}:\\d{2}:\\d{2}"),
    # Convert to seconds
    elapsed_seconds = period_to_seconds(hms(time_str))
    ) |>
  filter(elapsed_seconds >= percentile_threshold) |>
  rowwise() |>
  mutate(
    always_same_choice = n_distinct(c_across(all_of(cbc_cols)), na.rm = TRUE) == 1) |>
    ungroup() |>
  # filter out always same choices 
  filter(!always_same_choice)

# check how many surveys left
nrow(survey_robust)  
```

## Data Cleaning 


```{r message=FALSE, warning=FALSE}
# merge the survey, conjoint choices log and the demographic data set
conjoint <- survey |>
  left_join(choices, by = join_by(record_id)) |>
  left_join(demogr, by = join_by(prolific == participant_id)) |>
  mutate(age = as.numeric(age)) |>
  mutate(
    # Convert nonprofit_type
    nonprofit_type = case_when(
      nonprofit_type == 1 ~ "community arts center",
      nonprofit_type == 2 ~ "student tutoring center",
      nonprofit_type == 3 ~ "urban forestry center",
      nonprofit_type == 4 ~ "mental health center",
      TRUE ~ as.character(nonprofit_type) 
    ) |> factor(levels = c("community arts center", "student tutoring center",
                           "urban forestry center", "mental health center")),
    
    # Create rbi from core_service_price
    rbi = case_when(
      core_service_price == 1 ~ "free",
      core_service_price == 2 ~ "reduced price",
      core_service_price == 3 ~ "full price",
      TRUE ~ as.character(core_service_price)
    ) |> factor(levels = c("free", "reduced price", "full price")),
    
    # Convert use_of_donations
    use_of_donations = case_when(
      use_of_donations == 1 ~ "paying program staff",
      use_of_donations == 2 ~ "capacity building",
      use_of_donations == 3 ~ "rainy day funds",
      use_of_donations == 4 ~ "unrestricted use",
      TRUE ~ as.character(use_of_donations)
    ) |> factor(levels = c("paying program staff", "capacity building",
                           "rainy day funds", "unrestricted use")),
    
    # Create ubi from side_business
    ubi = case_when(
      side_business == 1 ~ "none",
      side_business == 2 ~ "event space rental",
      side_business == 3 ~ "running a pizza shop",
      TRUE ~ as.character(side_business)
    ) |> factor(levels = c("none", "event space rental", "running a pizza shop")),
    
    # Create financial_situation from nonprofit_financial_situation
    financial_situation = case_when(
      nonprofit_financial_situation == 1 ~ "in good condition",
      nonprofit_financial_situation == 2 ~ "under financial stress",
      TRUE ~ as.character(nonprofit_financial_situation)
    ) |> factor(levels = c("in good condition", "under financial stress"))
  ) |>
  mutate(across(c(rbi, ubi, nonprofit_type, use_of_donations, financial_situation), 
                ~ stringr::str_to_sentence(.)))

```


```{r}
# checking how much of the conjoint survey has demographic data available
summary(conjoint$age)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
#  19.00   33.00   46.00   45.77   59.00   89.00     990 

990 / nrow(conjoint) # 2.8% of the data missing age value
```

```{r}
# covert choice levels for multinomial regression
conjoint_choice_alt <- conjoint |>
  mutate(choice_alt = factor(concept * response)) 
```


## Short test brms model

```{r}
# Test with a subset of data and simpler model
#test_data <- conjoint_choice_alt %>% sample_n(100)  # Smaller sample

#test_model <- brm(
#  bf(choice_alt ~ rbi + ubi),  # Fewer predictors
#  data = test_data,
#  family = categorical(refcat = "0"),
#  chains = 2,  
#  iter = 1000,  
#  warmup = 500,
#  seed = 8207,
#  refresh = 10  # Show progress
#)

#summary(test_model)
```


## Running brms model

1. model_conjoint_brms0: with data before reassigning the reference level
2. model_conjoint_brms2: model with 0 intercept
3. model_conjoint_brms3: model with constant term

```{r}
# run the Bayesian model with brm
model_conjoint2 <- brm(
  bf(choice_alt ~ 0 + rbi + ubi + nonprofit_type + use_of_donations + financial_situation + (1 | prolific)),
  data = conjoint_choice_alt,
  family = categorical(refcat = "0"),
  prior = c(
    prior(normal(0, 3), class = b, dpar = mu1),
    prior(normal(0, 3), class = b, dpar = mu2),
    prior(normal(0, 3), class = b, dpar = mu3),
    prior(exponential(1), class = sd, dpar = mu1),
    prior(exponential(1), class = sd, dpar = mu2),
    prior(exponential(1), class = sd, dpar = mu3)
  ),
  chains = 4, cores = 16, iter = 4000, warmup = 1000, seed = 8207,
  backend = "cmdstanr", threads = threading(4), refresh = 100,
  file = here("output", "model_conjoint_brms2")
)

```


```{r}
model_conjoint = model_conjoint2
```


```{r}
summary(model_conjoint3)
```


## Tidy model restuls - collapse the three choices options 
```{r message=FALSE, warning=FALSE}
conjoint_cat_marginalized <- model_conjoint %>% 
  gather_draws(`^b_.*$`, regex = TRUE) %>% 
  # Each variable name has "mu1", "mu2", etc. built in, like "b_mu1_seat6". This
  # splits the .variable column into two parts based on a regular expression,
  # creating one column for the mu part ("b_mu1_") and one for the rest of the
  # variable name ("seat6")
  separate_wider_regex(
    .variable,
    patterns = c(mu = "b_mu\\d_", .variable = ".*")
  ) %>% 
  # Find the average of the three mu estimates for each variable within each
  # draw, or marginalize across the three options, since they're randomized
  group_by(.variable, .draw) %>% 
  summarize(.value = mean(.value))

conjoint_cat_marginalized |>
                distinct(.variable)
```


```{r}
conjoint_cat_marginalized %>% 
  median_qi()
```



```{r}
conjoint_cat_marginalized %>% 
  group_by(.variable) %>% 
  median_qi()
```


```{r}
# run the Bayesian model with brm
model_conjoint3 <- brm(
  bf(choice_alt ~ rbi + ubi + nonprofit_type + use_of_donations + financial_situation + (1 | prolific)),
  data = conjoint_choice_alt,
  family = categorical(refcat = "0"),
  prior = c(
    prior(normal(0, 3), class = b, dpar = mu1),
    prior(normal(0, 3), class = b, dpar = mu2),
    prior(normal(0, 3), class = b, dpar = mu3),
    prior(exponential(1), class = sd, dpar = mu1),
    prior(exponential(1), class = sd, dpar = mu2),
    prior(exponential(1), class = sd, dpar = mu3)
  ),
  chains = 4, cores = 16, iter = 4000, warmup = 1000, seed = 8207,
  backend = "cmdstanr", threads = threading(4), refresh = 100,
  file = here("output", "model_conjoint_brms3")
)
```


```{r}
conjoint_cat_marginalized3 <- model_conjoint3 %>% 
  gather_draws(`^b_.*$`, regex = TRUE) %>% 
  # Each variable name has "mu1", "mu2", etc. built in, like "b_mu1_seat6". This
  # splits the .variable column into two parts based on a regular expression,
  # creating one column for the mu part ("b_mu1_") and one for the rest of the
  # variable name ("seat6")
  separate_wider_regex(
    .variable,
    patterns = c(mu = "b_mu\\d_", .variable = ".*")
  ) %>% 
  # Find the average of the three mu estimates for each variable within each
  # draw, or marginalize across the three options, since they're randomized
  group_by(.variable, .draw) %>% 
  summarize(.value = mean(.value))

conjoint_cat_marginalized3 |>
                distinct(.variable)
```


Checking the distribution of rbi_free coefficients.
```{r}
conjoint_cat_marginalized3 %>% 
  filter(.variable == "rbifullprice") %>% 
  ggplot(aes(x = .value, y = .variable)) +
  stat_halfeye(fill = clrs[4]) +
  labs(x = "Posterior distribution of β (logit-scale)", y = NULL)
```


## Predictions for specified categories

```{r}
# avg_predictions(model_conjoint)
```


Just curious how the distribution of non-zero options are like since I have some tasks with the choice of "none"

It's ~ 30% a little lower than the 33% 




## Predictions data preparation


```{r}
# pull a random prolific number
prolific_id1 <- sample(conjoint$prolific, 1)
# derive all possible combinations of feature levels
newdata_all_combos <- conjoint |> 
  tidyr::expand(rbi, ubi, nonprofit_type, use_of_donations, financial_situation) |>
  mutate(prolific = prolific_id1) 
newdata_all_combos
```

Derive the whole posterior prediction data 

```{r}
# predicted data
all_preds_brms <- model_conjoint |> 
  epred_draws(newdata = newdata_all_combos) |>
  filter(.category == 0) |> 
  mutate(.epred = 1 - .epred)
```


```{r version without 0 term}
all_preds_brms3 <- model_conjoint3 |> 
  epred_draws(newdata = newdata_all_combos) |>
  filter(.category == 0) |> 
  mutate(.epred = 1 - .epred)
```


Check the multiple combination of possible levels 

```{r}
# quick summary of the predictions by levels
all_preds_brms |>
  group_by(rbi, ubi, nonprofit_type, use_of_donations, financial_situation) |>
  median_qi(.epred)

```

## AMECS all in one

rbi, ubi, nonprofit_type, use_of_donations, financial_situation

```{r}
# 
amces_conjoint <- bind_rows(
  rbi = all_preds_brms |>
    group_by(rbi, .draw) |>
    summarize(avg = mean(.epred)) |> 
    compare_levels(variable = avg, by = rbi, comparison = "control") |>  
    rename(contrast = rbi),
  ubi = all_preds_brms |> 
    group_by(ubi, .draw) |> 
    summarize(avg = mean(.epred)) |>  
    compare_levels(variable = avg, by = ubi, comparison = "control") |>  
    rename(contrast = ubi),
  nonprofit_type = all_preds_brms |>  
    group_by(nonprofit_type, .draw) |> 
    summarize(avg = mean(.epred)) |> 
    compare_levels(variable = avg, by = nonprofit_type, comparison = "control") |>  
    rename(contrast = nonprofit_type),
  use_of_donations = all_preds_brms |> 
    group_by(use_of_donations, .draw) |> 
    summarize(avg = mean(.epred)) |> 
    compare_levels(variable = avg, by = use_of_donations, comparison = "control") |>  
    rename(contrast = use_of_donations),
  
  financial_situation = all_preds_brms |>  
    group_by(financial_situation, .draw) |> 
    summarize(avg = mean(.epred)) |>  
    compare_levels(variable = avg, by = financial_situation, comparison = "control") |> 
    rename(contrast = financial_situation),
  .id = "term"
) |> 
  mutate(term = factor(term, 
                       levels = c("rbi", "ubi", "nonprofit_type", 
                                  "use_of_donations", "financial_situation")))
  

amces_conjoint |> 
  group_by(term, contrast) |>
  median_qi(avg)

```


```{r}
direct_var_levels <- tibble(
  variable = c("rbi", "ubi", "nonprofit_type", "use_of_donations", "financial_situation")
) |> 
  mutate(levels = map(variable, ~{
    x <- conjoint_choice_alt[[.x]]
    if (is.numeric(x)) {
      ""
    } else if (is.factor(x)) {
      levels(x)
    } else {
      sort(unique(x))
    }
  })) %>% 
  unnest(levels) %>% 
  mutate(term = paste0(variable, levels))

# Make a little lookup table for nicer feature labels
direct_var_lookup <- tribble(
  ~variable, ~variable_nice,
  "rbi",                    "RBI",
  "ubi",                    "UBI",
  "nonprofit_type",         "Nonprofit Types",
  "use_of_donations",       "Use of Donations",
  "financial_situation",    "Financial Situation"
) |> 
  mutate(variable_nice = fct_inorder(variable_nice))
```


```{r fig.height=8, fig.width=9}
# Direct AMCEs All in one
posterior_amces_nested <- amces_conjoint |> 
  separate_wider_delim(
    contrast,
    delim = " - ", 
    names = c("variable_level", "reference_level")
  ) |> 
  group_by(term, variable_level) |> 
  nest()

plot_data_amce <- direct_var_levels |>
  left_join(
    posterior_amces_nested,
    by = join_by(variable == term, levels == variable_level)
  ) %>%
  mutate(data = map_if(data, is.null, ~ tibble(avg = 0))) |> 
  unnest(data) |>
  left_join(direct_var_lookup, by = join_by(variable)) |> 
  mutate(across(c(levels, variable_nice), ~fct_inorder(.))) 

p1 <- plot_data_amce |>
  ggplot(aes(x = avg, y = fct_rev(levels), fill = variable_nice)) +
  geom_vline(xintercept = 0) +
  stat_halfeye() + 
  facet_col(facets = "variable_nice", scales = "free_y", space = "free") +
  scale_x_continuous(labels = label_pp) +

  scale_fill_manual(values = clrs[c(3, 7, 8, 9, 11)], guide = "none") +
  labs(
    x = "Percentage point change in probability of donations",
    y = NULL,
    title = "Posterior AMCEs",
    slab_alpha = NULL
  ) +
  theme(
    legend.position = "top",
    legend.justification = "left",
    legend.margin = margin(l = -7, t = 0)
  )
p1
```



## MMs

```{r message=FALSE, warning=FALSE}
mms_conjoint <- bind_rows(
  rbi = all_preds_brms |>
    group_by(variable_level = rbi, .draw) |>
    summarize(avg = mean(.epred)),
  
  ubi = all_preds_brms |> 
    group_by(variable_level = ubi, .draw) |> 
    summarize(avg = mean(.epred)),
  
  nonprofit_type = all_preds_brms |>  
    group_by(variable_level = nonprofit_type, .draw) |> 
    summarize(avg = mean(.epred)),
  
  use_of_donations = all_preds_brms |> 
    group_by(variable_level = use_of_donations, .draw) |> 
    summarize(avg = mean(.epred)),
  
  financial_situation = all_preds_brms |>  
    group_by(variable_level = financial_situation, .draw) |> 
    summarize(avg = mean(.epred)),
  .id = "term"
) |> 
  mutate(term = factor(term, 
                       levels = c("rbi", "ubi", "nonprofit_type", 
                                  "use_of_donations", "financial_situation")))
  

mms_conjoint |> 
  group_by(term, variable_level) |>
  median_qi(avg)
```


```{r fig.height=8, fig.width=9}
# Direct AMCEs All in one
posterior_mms_nested <- mms_conjoint |> 
  group_by(term, variable_level) |> 
  nest()

plot_data_mm <- direct_var_levels |>
  left_join(
    posterior_mms_nested,
    by = join_by(variable == term, levels == variable_level)
  ) |>
  unnest(data) |>
  left_join(direct_var_lookup, by = join_by(variable)) |> 
  mutate(across(c(levels, variable_nice), ~fct_inorder(.))) 

p2 <- plot_data_mm |>
  ggplot(aes(x = avg, y = fct_rev(levels), fill = variable_nice)) +
  geom_vline(xintercept = 0) +
  stat_halfeye() + 
  facet_col(facets = "variable_nice", scales = "free_y", space = "free") +
  scale_x_continuous(labels = label_percent(accuracy = 1)) +

  scale_fill_manual(values = clrs[c(3, 7, 8, 9, 11)], guide = "none") +
  labs(
    x = "Marginal means of probabilities",
    y = NULL,
    title = "Posterior marginal means ",
    slab_alpha = NULL
  ) +
  theme(
    legend.position = "top",
    legend.justification = "left",
    legend.margin = margin(l = -7, t = 0)
  )
p2
```

```{r fig.height=8, fig.width=12}
p1 | p2
```






## Interactions 



### 1.rbi

```{r message=FALSE, warning=FALSE}
preds_rbi_marginalized <- all_preds_brms |>
  group_by(rbi, .draw) |>
  summarize(avg = mean(.epred))
```

Check out the values of amce and mm

**AMCE** of rbi only 

```{r}
# amce median
preds_rbi_marginalized %>%
  compare_levels(variable = avg, by = rbi, comparison = "control") %>% 
  median_qi(avg)
```

**MMs** of rbi only

```{r}
# mm median 
mm_rbi <- preds_rbi_marginalized |>
  group_by(rbi) |>
  median_qi()

mm_rbi |>
  summarize(avg_p = mean(avg))
```



**Marginal means**

```{r plot rbi mm}
# pull vline value
rbi_benchmarks <- mm_rbi %>%
  select(rbi, avg) %>%
  filter(rbi %in% c("free", "reduced price", "full price"))


p_rbi <- preds_rbi_marginalized %>% 
  ggplot(aes(x = avg, y = fct_rev(rbi), fill = rbi)) +
  stat_halfeye() +
  geom_vline(data = rbi_benchmarks, 
             aes(xintercept = avg, color = rbi), 
             linetype = "dashed",
             linewidth = 0.75) +
  geom_vline(xintercept = 0.25, 
             color = "black", 
             linetype = "solid",
             linewidth = 0.7) +
  scale_x_continuous(labels = label_percent(), limits = c(0.1, 0.55) ) +
  scale_color_manual(values = colorspace::darken(clrs[c(11, 7, 3)], 0.3), guide = "none") +
  scale_fill_manual(values = colorspace::darken(clrs[c(11, 7, 3)], 0.3), guide = "none") +
  labs(x = NULL, y = NULL, 
       title = "Overall RBI Marginal Means") +
  theme_bw() +
  theme(
    plot.title = element_textbox_simple(
      face = "bold",
      fill = "grey75",
      size = rel(0.85),
      halign = 0,
      linetype = 1,
      linewidth = 0.2,
      padding = margin(5, 5, 5, 5)
    ),
    strip.background = element_rect(fill = "grey92"),
    strip.text = element_text(hjust = 0)
  )
p_rbi
```



model w/ constant

```{r message=FALSE, warning=FALSE}
preds_rbi_marginalized3 <- all_preds_brms3 |>
  group_by(rbi, .draw) |>
  summarize(avg = mean(.epred))

preds_rbi_marginalized3 |>
  group_by(rbi) |>
  median_qi()
```
It's the same.



rbi * use

```{r message=FALSE, warning=FALSE}
preds_rbi_use_marginalized <- all_preds_brms |>
  group_by(rbi, use_of_donations, .draw) |>
  summarize(avg = mean(.epred))

preds_rbi_use_marginalized |>
  group_by(rbi, use_of_donations) |>
  median_qi()
```



```{r fig.height=7, fig.width=7}
p_rbi_use <- preds_rbi_use_marginalized |>
  ggplot(aes(x = avg, y = fct_rev(rbi), fill = rbi, slab_alpha = use_of_donations)) +
  stat_halfeye(normalize = "groups") +
  geom_vline(data = rbi_benchmarks, 
             aes(xintercept = avg, color = rbi), 
             linetype = "dashed",
             linewidth = 0.75) +
  geom_vline(xintercept = 0.25, 
             color = "black", 
             linetype = "solid",
             linewidth = 0.7) +

  scale_x_continuous(labels = label_percent(), limits = c(0.1, 0.55) ) +
  scale_color_manual(values = colorspace::darken(clrs[c(11, 7, 3)], 0.3), guide = "none") +
  scale_fill_manual(values = colorspace::darken(clrs[c(11, 7, 3)], 0.3), guide = "none") +
  scale_slab_alpha_discrete(
    range = c(0.8, 0.4),
    guide = "none"
  ) +
  facet_wrap(vars(use_of_donations), ncol = 1) +
  labs(x = "Predicted probability of donation", y = NULL,  
       title = "RBI × Use of donations Marginal Means") +
  theme_bw() +
  theme(
    plot.title = element_textbox_simple(
      face = "bold",
      fill = "grey75",
      size = rel(0.9),
      halign = 0,
      linetype = 1,
      linewidth = 0.2,
      padding = margin(5, 5, 5, 5)
    ),
    strip.background = element_rect(fill = "grey92"),
    strip.text = element_text(hjust = 0)
  )
p_rbi_use
```




```{r fig.height=8, fig.width=9.5}
p_rbi / p_rbi_use +
   plot_layout(heights = c(1, 5)) 
```

### 2.ubi

**AMCE** of ubi only 

```{r}
preds_ubi_marginalized %>%
  compare_levels(variable = avg, by = ubi, comparison = "control") %>% 
  median_qi(avg)
```

**MMs** of ubi only

```{r message=FALSE, warning=FALSE}
preds_ubi_marginalized <- all_preds_brms |>
  group_by(ubi, .draw) |>
  summarize(avg = mean(.epred))
```


```{r}
# mm median 
mm_ubi <- preds_ubi_marginalized |>
  group_by(ubi) |>
  median_qi()
```



```{r plot ubi mm}
# pull vline value
ubi_benchmarks <- c(
  mm_ubi %>% filter(ubi == "none") %>% pull(avg),
  mm_ubi %>% filter(ubi == "event space rental") %>% pull(avg),
  mm_ubi %>% filter(ubi == "running a pizza shop") %>% pull(avg)
)
p_ubi <- preds_ubi_marginalized %>% 
  ggplot(aes(x = avg, y = fct_rev(ubi), fill = ubi)) +
  stat_halfeye() +
  geom_vline(xintercept = rbi_benchmarks, 
             color = "red", 
             linetype = "dashed",
             linewidth = 0.5) +
  facet_wrap(vars("Overall UBI Marginal Means")) +
  scale_x_continuous(labels = label_percent(), limits = c(0.2, 0.4) ) +
  scale_fill_manual(values = clrs[c(11, 7, 3)], guide = "none") +
  labs(x = NULL, y = "UBI") +
  theme(
    panel.background = element_rect(fill = "grey80", color = NA)
  )

p_ubi
```


ubi * use

```{r message=FALSE, warning=FALSE}
preds_ubi_use_marginalized <- all_preds_brms |>
  group_by(ubi, use_of_donations, .draw) |>
  summarize(avg = mean(.epred))

preds_ubi_use_marginalized |>
  group_by(ubi, use_of_donations) |>
  median_qi()
```



```{r fig.height=7, fig.width=7}
p_ubi_use <- preds_ubi_use_marginalized |>
  ggplot(aes(x = avg, y = fct_rev(ubi), fill = ubi, slab_alpha = use_of_donations)) +
  stat_halfeye(normalize = "groups") +
  geom_vline(xintercept = ubi_benchmarks, 
             color = "red", 
             linetype = "dashed",
             linewidth = 0.5) +
  scale_x_continuous(labels = label_percent(),  limits = c(0.2, 0.4) ) +
  scale_slab_alpha_discrete(
    range = c(0.8, 0.2),
    guide = "none"
  ) +
  facet_wrap(vars(use_of_donations), ncol = 1) +
  scale_fill_manual(values = clrs[c(11, 7, 3)], guide = "none") +
  labs(x = "Predicted probability of donation", y = "UBI * USE")
p_ubi_use
```

```{r fig.height=6, fig.width=8}
p_ubi / p_ubi_use +
   plot_layout(heights = c(1, 4)) 
```


分割线

extra codes below


```{r}
preds_ubi_use_marginalized %>% 
  ggplot(aes(x = avg, y = fct_rev(ubi), slab_alpha = use_of_donations)) +
  stat_halfeye(fill = clrs[3]) + 
  scale_x_continuous(labels = label_percent()) +
  scale_slab_alpha_discrete(
    range = c(0.15, 1),
    guide = guide_legend(
      reverse = TRUE, 
      override.aes = list(fill = "grey10"), 
      keywidth = 0.8, 
      keyheight = 0.8
    )
  ) +
  labs(
    x = "Marginal means",
    y = "UBI",
    slab_alpha = "Use of Donations"
  ) +
  theme(
    legend.position = "top",
    legend.justification = "left",
    legend.margin = margin(l = -7, t = 0)
  )
```








ubi * use

```{r message=FALSE, warning=FALSE}
preds_ubi_use_marginalized <- all_preds_brms |>
  group_by(ubi, use_of_donations, .draw) |>
  summarize(avg = mean(.epred))

preds_ubi_use_marginalized |>
  group_by(ubi, use_of_donations) |>
  median_qi()
```

```{r fig.height=7, fig.width=7}
preds_ubi_use_marginalized |>
  ggplot(aes(x = avg, y = fct_rev(ubi), slab_alpha = use_of_donations)) +
  stat_halfeye(normalize = "groups", fill = clrs[10]) +
  scale_x_continuous(labels = label_percent()) +
  scale_slab_alpha_discrete(
    range = c(1, 0.4),
    guide = "none"
  ) +
  facet_wrap(vars(use_of_donations), ncol = 1) +
  
  labs(x = "Predicted probability of donation", y = "UBI")
```

```{r}
preds_ubi_use_marginalized %>% 
  ggplot(aes(x = avg, y = fct_rev(ubi), slab_alpha = use_of_donations)) +
  stat_halfeye(fill = clrs[3]) + 
  scale_x_continuous(labels = label_percent()) +
  scale_slab_alpha_discrete(
    range = c(0.15, 1),
    guide = guide_legend(
      reverse = TRUE, 
      override.aes = list(fill = "grey10"), 
      keywidth = 0.8, 
      keyheight = 0.8
    )
  ) +
  labs(
    x = "Marginal means",
    y = "UBI",
    slab_alpha = "Use of Donations"
  ) +
  theme(
    legend.position = "top",
    legend.justification = "left",
    legend.margin = margin(l = -7, t = 0)
  )
```




